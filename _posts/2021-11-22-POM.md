---
layout: post
title: "POM结构"
date: 2021-10-15
description: "层级目录POM多环境配置文件"
tag: hexo
---   
## 介绍
以下为层级目录POM多环境配置文件

## POM 层级
依赖配置如下：
pom <project> 下一个标签 <profiles>  ==》 和 <dependencies> 以及 <build> 并列

    <profiles>
    <profile>
      <id>dev</id>
      <build>
        <resources>
          <resource>
            <directory>src/main/profiles/dev</directory>
          </resource>
          <resource>
            <directory>src/main/resources</directory>
          </resource>
        </resources>
      </build>
    </profile>
    <profile>
      <id>test</id>
      <activation>
        <activeByDefault>true</activeByDefault>
      </activation>
      <build>
        <resources>
          <resource>
            <directory>src/main/profiles/test</directory>
          </resource>
          <resource>
            <directory>src/main/resources</directory>
          </resource>
        </resources>
      </build>
    </profile>
    <profile>
      <id>staging</id>
      <build>
        <resources>
          <resource>
            <directory>src/main/profiles/staging</directory>
          </resource>
          <resource>
            <directory>src/main/resources</directory>
          </resource>
        </resources>
      </build>
    </profile>
    <profile>
      <id>prod</id>
      <build>
        <resources>
          <resource>
            <directory>src/main/profiles/prod</directory>
          </resource>
          <resource>
            <directory>src/main/resources</directory>
          </resource>
        </resources>
      </build>
    </profile>
    </profiles>
## 配置文件 层级
    1.src/main/java  com.
    2.src/main/profiles 
    3.src/main/resources
    编译之后 classes文件夹下 
    com 和 profiles/prod(test) 下的文件是同级别， 注意：profiles/prod(test) 和  resources 文件夹本身是不展示的，只展示下一级的文件或者文件夹

## scope解释
    scope元素的作用：控制 dependency 元素的使用范围。通俗的讲，就是控制 Jar 包在哪些范围被加载和使用。
            scope具体含义如下：
            
            compile（默认）
            含义：compile 是默认值，如果没有指定 scope 值，该元素的默认值为 compile。被依赖项目需要参与到当前项目的编译，测试，打包，运行等阶段。打包的时候通常会包含被依赖项目。
            
            provided
            含义：被依赖项目理论上可以参与编译、测试、运行等阶段，相当于compile，但是再打包阶段做了exclude的动作。
            适用场景：例如， 如果我们在开发一个web 应用，在编译时我们需要依赖 servlet-api.jar，但是在运行时我们不需要该 jar 包，因为这个 jar 包已由应用服务器提供，此时我们需要使用 provided 进行范围修饰。
            
            runtime
            含义：表示被依赖项目无需参与项目的编译，但是会参与到项目的测试和运行。与compile相比，被依赖项目无需参与项目的编译。
            适用场景：例如，在编译的时候我们不需要 JDBC API 的 jar 包，而在运行的时候我们才需要 JDBC 驱动包。
            
            test
            含义： 表示被依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。
            适用场景：例如，Junit 测试。
            
            system
            含义：system 元素与 provided 元素类似，但是被依赖项不会从 maven 仓库中查找，而是从本地系统中获取，systemPath 元素用于制定本地系统中 jar 文件的路径。例如：
            
            <dependency>
                <groupId>org.open</groupId>
                <artifactId>open-core</artifactId>
                <version>1.5</version>
                <scope>system</scope>
                <systemPath>${basedir}/WebContent/WEB-INF/lib/open-core.jar</systemPath>
            </dependency>
            import
            它只使用在<dependencyManagement>中，表示从其它的pom中导入dependency的配置，例如 (B项目导入A项目中的包配置)：
            
            想必大家在做SpringBoot应用的时候，都会有如下代码：
            
            <parent>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-parent</artifactId>
                <version>1.3.3.RELEASE</version>
            </parent>
            继承一个父模块，然后再引入相应的依赖。
            假如说，我不想继承，或者我想继承多个，怎么做？
            
            我们知道Maven的继承和Java的继承一样，是无法实现多重继承的，如果10个、20个甚至更多模块继承自同一个模块，那么按照我们之前的做法，这个父模块的dependencyManagement会包含大量的依赖。如果你想把这些依赖分类以更清晰的管理，那就不可能了，import scope依赖能解决这个问题。你可以把dependencyManagement放到单独的专门用来管理依赖的pom中，然后在需要使用依赖的模块中通过import scope依赖，就可以引入dependencyManagement。例如可以写这样一个用于依赖管理的pom：
            
            <project>
                <modelVersion>4.0.0</modelVersion>
                <groupId>com.test.sample</groupId>
                <artifactId>base-parent1</artifactId>
                <packaging>pom</packaging>
                <version>1.0.0-SNAPSHOT</version>
                <dependencyManagement>
                    <dependencies>
                        <dependency>
                            <groupId>junit</groupId>
                            <artifactid>junit</artifactId>
                            <version>4.8.2</version>
                        </dependency>
                        <dependency>
                            <groupId>log4j</groupId>
                            <artifactid>log4j</artifactId>
                            <version>1.2.16</version>
                        </dependency>
                    </dependencies>
                </dependencyManagement>
            </project>
            然后我就可以通过非继承的方式来引入这段依赖管理配置
            
            <dependencyManagement>
                <dependencies>
                    <dependency>
                        <groupId>com.test.sample</groupId>
                        <artifactid>base-parent1</artifactId>
                        <version>1.0.0-SNAPSHOT</version>
                        <type>pom</type>
                        <scope>import</scope>
                    </dependency>
                </dependencies>
            </dependencyManagement>
            
            <dependency>
                <groupId>junit</groupId>
                <artifactid>junit</artifactId>
            </dependency>
            <dependency>
                <groupId>log4j</groupId>
                <artifactid>log4j</artifactId>
            </dependency>
            注意：import scope只能用在dependencyManagement里面
            
            这样，父模块的pom就会非常干净，由专门的packaging为pom来管理依赖，也契合的面向对象设计中的单一职责原则。此外，我们还能够创建多个这样的依赖管理pom，以更细化的方式管理依赖。这种做法与面向对象设计中使用组合而非继承也有点相似的味道。
            
            那么，如何用这个方法来解决SpringBoot的那个继承问题呢？
            
            配置如下：
            
            <dependencyManagement>
                <dependencies>
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-dependencies</artifactId>
                        <version>1.3.3.RELEASE</version>
                        <type>pom</type>
                        <scope>import</scope>
                    </dependency>
                </dependencies>
            </dependencyManagement>
            
            <dependencies>
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-web</artifactId>
                </dependency>
            </dependencies>
            这样配置的话，自己的项目里面就不需要继承SpringBoot的module了，而可以继承自己项目的module了。
            
            scope的依赖传递
            A–>B–>C。当前项目为A，A依赖于B，B依赖于C。知道B在A项目中的scope，那么怎么知道C在A中的scope呢？答案是：
            当C是test或者provided时，C直接被丢弃，A不依赖C；
            否则A依赖C，C的scope继承于B的scope。
            
            下面是一张nexus画的图。
            https://upload-images.jianshu.io/upload_images/2689526-874dc44e81a0bcd1.png?imageMogr2/auto-orient/strip|imageView2/2/w/772/format/webp



